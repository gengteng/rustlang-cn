# `async`/`await!`


在[第一章]中，我们简要介绍了`async/ await!`并使用它来构建一个简单的服务器。本章将更详细地讨论`async/ await!`解释它如何工作以及`async`代码与传统Rust程序的不同之处。

`async/ await!`是Rust语法的特殊部分，可以控制当前线程而不阻塞，允许其他代码在等待操作完成时取得进展。

`async`有三种主要的使用方法：`async fn`，`async块`和 `async闭包`。每个返回一个实现`Future`特征的值：

```rust
// `foo()` returns a type that implements `Future<Output = u8>`.
// `await!(foo())` will result in a value of type `u8`.
async fn foo() -> u8 { 5 }

fn bar() -> impl Future<Output = u8> {
    // This `async` block results in a type that implements
    // `Future<Output = u8>`.
    async {
        let x: u8 = await!(foo());
        x + 5
    }
}

fn baz() -> impl Future<Output = u8> {
    // This `async` closure, when called, returns a type that
    // implements `Future<Output = u8>`
    let closure = async |x: u8| {
        await!(bar()) + x
    };
    closure(5)
}
```

正如我们在第一章中看到的那样，`async`和其他`Future`是懒惰的：它们在运行之前什么都不做。运行`Future`的最常见方式是`await!`它。当在Future`上调用`await!`时，它将尝试运行以完成它。如果`Future`被阻止，它将让出当前线程。当可以取得更多进展时，执行者将获取 `Future`并将继续运行，以便`await!`解决。

## `async` 生命周期

`async fn`与传统函数不同，带引用或其他非`'static`参数的,返回一个受参数生命周期限制的`Future`：
Unlike traditional functions, `async fn`s which take references or other
non-`'static` arguments return a `Future` which is bounded by the lifetime of
the arguments:

```rust
// This function:
async fn foo(x: &u8) -> u8 { *x }

// Is equivalent ot this function:
fn foo<'a>(x: &'a u8) -> impl Future<Output = ()> + 'a {
    async { *x }
}
```

This means that the future returned from an `async fn` must be `await!`ed
while its non-`'static` arguments are still valid. In the common
case of `await!`ing the future immediately after calling the function
(like `await!(foo(&x))`) this is not an issue. However, if storing the future
or sending it over to another task or thread, this may be an issue.

One common workaround for turning an `async fn` with references-as-arguments
into a `'static` future is to bundle the arguments with the call to the
`async fn` inside an `async` block:

```rust
async fn foo(x: &u8) -> u8 { *x }

fn bad() -> impl Future<Output = ()> {
    let x = 5;
    foo(&x) // ERROR: `x` does not live long enough
}

fn good() -> impl Future<Output = ()> {
    async {
        let x = 5;
        await!(foo(&x))
    }
}
```

By moving the argument into the `async` block, we extend its lifetime to match
that of the `Future` returned from the call to `foo`.

## `async move`

`async` blocks and closures allow the `move` keyword, much like normal
closures. An `async move` block will take ownership of the variables it
references, allowing it to outlive the current scope, but giving up the ability
to share those variables with other code:

```rust
/// `async` block:
///
/// Multiple different `async` blocks can access the same local variable
/// so long as they're executed within the variable's scope.
async fn foo() {
    let my_string = "foo".to_string();

    let future_one = async {
        ...
        println!("{}", my_string);
    };

    let future_two = async {
        ...
        println!("{}", my_string);
    };
    // Run both futures to completion, printing "foo" twice
    let ((), ()) = join!(future_one, future_two);
}

/// `async move` block:
///
/// Only one `async` block can access captured variables, since they are
/// moved into the `Future` generated by the `async` block. However,
/// this allows the `Future` to outlive the original scope of the variable:
fn foo() -> impl Future<Output = ()> {
    let my_string = "foo".to_string();
    async move {
        ...
        println!("{}", my_string);
    }
}
```

## `await!`ing on a Multithreaded Executor

Note that, when using a multithreaded `Future` executor, a `Future` may move
between threads, so any variables used in `async` bodies must be able to travel
between threads, as any `await!` can potentially result in a switch to a new
thread.

This means that it is not safe to use `Rc`, `&RefCell` or any other types
that don't implement the `Send` trait, including references to types that don't
implement the `Sync` trait.

(Caveat: it is possible to use these types so long as they aren't in scope
during a call to `await!`.)

Similarly, it isn't a good idea to hold a traditional non-futures-aware lock
across an `await!`, as it can cause the threadpool to lock up: one task could
take out a lock, `await!` and yield to the executor, allowing another task to
attempt to take the lock and cause a deadlock. To avoid this, use the `Mutex`
in `futures::lock` rather than the one from `std::sync`.

[the first chapter]: TODO ../getting_started/async_await_primer.md
